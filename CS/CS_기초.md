# CS 기초
1. 고급언어와 저급언어의 차이점을 설명해주세요.
    - 고급 언어 : 사람이 이해하고 작성할 수 있는 언어
    - 저급 언어 : 컴퓨터가 이해하고 실행할 수 있는 언어
2. 저급언어의 기계어와 어셈블리어 차이점을 설명해주세요.
    - 기계어 : 2진수로 이루어진 명령어
    - 어셈블리어 : 기계어를 번역한 언어
3. 컴파일러와 인터프리터 차이점을 설명해주세요.
    - 컴파일러 : 코드 전체를 저급 언어로 변환
    - 인터프리터 : 코드 한 줄씩 실행
4. 컴파일 과정을 설명해주세요.
    - 기계어 > 어셈블러 > 컴파일(목적 코드) > 링커(라이브러리) > 실행 파일
5. 명령어의 구조를 설명해주세요.
    - 연산 코드 : 명령어가 수행할 연산
    - 오퍼랜드 : 연산에 사용할 데이터 또는 저장된 위치
6. 명령어의 인출 사이클을 설명해주세요.
    1. PC : 실행할 명령어의 주소 저장
    2. MAR : 주소버스로 전송하기 위해 명령어 주소 저장
    3. 명령어를 읽기 위해 **읽기** 제어신호와 MAR의 값이 각각 제어/주소 버스를 통해 메모리로 전송
    4. MBR : 해당 주소에 저장된 값은 데이터 버스를 통해 MBR로 전달, PC는 다음 명령어를 읽기 위해 증가
    5. IR : MBR의 값은 IR로 이동하고 CU는 IR 내 명령어를 해석하고 제어신호 발생
7. ALU, CU의 역할은 무엇인지 각각의 입출력은 무엇인지 설명해주세요.
    - ALU
        - 연산을 담당하는 부품
        - 입력 : 피연산자(레지스터), 제어신호(제어장치)
        - 출력 : 결괏값, 플래그(부호, 0, Overflow 등)
    - CU
        - 명령어를 해석하는 부품
        - 입력 : 클럭, 해석할 명령어, 플래그, 제어신호
        - 출력 : 제어신호
8. 하드웨어 인터럽트 처리 순서를 설명해주세요.
    1. CPU에 인터럽트 요청 신호 전달
    2. CPU가 인터럽트를 처리할 수 있는지 플래그 레지스터 내 인터럽트 플래그 확인
    3. 현재 실행 중인 프로그램 중단 및 상태(PC, SR등)를 스택에 저장
    4. 인터럽트 요청 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달 받음
    5. 인터럽트 벡터로부터 인터럽트 서비스 루틴의 시작 주소를 확인하고 실행 및 작업 처리
    6. 스택에 저장한 상태를 불러오고 중단된 프로그램 실행 재개
9. 멀티코어와 멀티스레드의 차이를 설명해주세요.
    - 멀티코어 : 명령어를 실행하는 부품이 n개인 CPU
    - 멀티스레드 : 하나의 코어에서 n개의 명령어를 동시 수행하는 CPU
10. CISC/RISC의 차이를 설명해주세요.
    - CISC : 복잡하고 다양한 명령어 집합(가변적)
    - RISC : 단순하고 적은 명령어 집합(고정적)
11. RAID 0, 1, 4의 특징을 설명해주세요.
    - RAID 0 : Stripe, 분산 저장
    - RAID 1 : Mirror, 복사본 저장
    - RAID 4 : Parity, 오류 검출 및 복구 정보 저장
12. 커널과 시스템 콜에 대해 설명해주세요.
    - 커널 : S/W가 H/W에 접근하기 위한 인터페이스 제공, H/W 자원 관리
    - 시스템 콜 : User mode의 프로세스가 Kernel mode의 자원에 접근하기 위한 인터페이스
13. 프로세스와 스레드의 차이점을 설명해주세요.
    - 프로세스 : OS에 의해 메모리 공간을 할당받아 실행 중인 프로그램
    - 스레드 : 하나의 프로세스 안에서 다양한 작업을 수행하는 최소 실행 단위
14. 멀티프로세스와 멀티스레드의 차이점을 설명해주세요.
    - 멀티프로세스
        - 하나의 프로그램을 여러 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하는 방식
        - 각 프로세스별로 독립된 메모리를 갖기 때문에 메모리 공간 소모가 많다.
        - 하나의 프로세스에 문제가 발생하여도 전체 애플리케이션에 영향을 주지 않는다.
    - 멀티스레드
        - 하나의 프로세스 내에서 여러 스레드가 작업을 수행하는 방식
        - 프로세스 내 메모리를 공유하기 때문에 메모리 공간 소모가 적다.
        - 하나의 스레드에 문제가 발생하면 해당 프로세스에 영향을 줄 수 있다.
        - 스레드가 생성될 때마다 메모리 영역 중 Stack을 제외한 나머지 영역(Code, Data, Heap)은 공유한다.
15. 데몬이란 무엇인지 설명해주세요.
    - 사용자와 상호작용하지 않고 특정 요청이 오면 작업을 수행하는 백그라운드 프로세스
16. 문맥 교환 과정에 대해 설명해주세요.
    - CPU 스케줄링 알고리즘에 의해 현재 실행 중인 프로세스/스레드가 CPU를 사용 중일 때 다른 프로세스/스레드에게 CPU를 양보해야 하는 경우 현재 프로세스의 상태를 PCB에 저장하고 다음 실행될 프로세스의 정보가 담긴 PCB를 읽어서 실행을 시작한다.
17. 프로세스 상태에 대해 설명해주세요.
    - 생성 : 메모리에 적재되어 PCB 할당
    - 준비 : CPU 할당 대기
    - 실행 : CPU 할당 받아 실행, 할당 시간을 모두 사용한 경우(Timer Interrupt) 준비 상태로 전환
    - 대기 :  I/O 작업이 발생하여 완료까지 대기하는 상태
    - 종료 : PCB와 메모리 정리
18. 프로세스 메모리 영역에 대해 설명해주세요.
    - code : 기계어로 이루어진 명령어, Readonly
    - data : 프로세스 종료까지 유지하는 데이터, 전역 & 정적 변수
    - heap : 사용자가 직접 할당, 메모리 누수 발생, 런타임 시 크기 결정
    - stack : 임시로 사용할 데이터, 매개 & 지역 변수, 컴파일 시 크기 결정
19. 선점형과 비선점형 스케줄링의 차이점에 대해 설명해주세요.
    - 선점형 : 프로세스가 CPU 자원을 사용하고 있더라도 OS가 자원을 강제로 빼앗아 다른 프로세스에 할당
    - 비선점형 : 프로세스가 종료되거나 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없음
20. Critical Section과 Race Condition이 무엇인지 설명해주세요.
    - Critical Section : 전역 변수와 같이 두 개 이상의 프로세스가 동시에 접근하여 문제가 발생하는 코드 영역
    - Race Condition : 여러 프로세스가 동시 다발적으로 Critical Section 내 코드를 실행하여 문제가 발생한 경우
21. 교착상태란 무엇인지, 교착상태가 발생할 수 있는 조건을 모두 설명해주세요.
    - 일련의 프로세스들이 서로가 가진 자원을 기다리며 Block된 상태
        - 인부 A,B가 망치와 드릴 둘 모두를 사용해야 한다고 가정할 때
            - 인부 A가 망치를 사용 중이고 드릴을 요구함
            - 인부 B가 드릴을 사용 중이고 망치를 요구함
            - 서로 원하는 공구를 상대방이 사용 중이라 작업이 끝날 때까지 대기해야 함
    - 필요조건
        - 상호배제 : 오직 하나의 프로세스만 Critical Section에 진입할 수 있도록 한다.
        - 점유대기 : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림
        - 비선점 : 프로세스가 작업을 마친 후 자원을 자발적으로 반환할 때까지 기다림
        - 순환대기 : 각 프로세스가 원을 그리듯이 다음 프로세스가 요구하는 자원을 가지고 있는 상태
22. Swap이란 무엇인지 설명해주세요.
    - 디스크의 일부분을 RAM처럼 사용하는 가상 메모리의 일부 영역
23. 요구 페이징 처리 순서를 서술해주세요.
    ![Demand paging](https://user-images.githubusercontent.com/14902866/276625153-7ce5d9b4-4f45-4cdc-a3a3-6a183202a51d.png)
        1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
        2. 해당 페이지가 현재 메모리에 있을 경우(valid bit : 1), CPU는 페이지가 적재된 프레임에 접근한다.
        3. 해당 페이지가 현재 메모리에 없을 경우(valid bit : 0), Page fault가 발생하고 trap을 발생시킨다.
        4. 페이지 폴트 처리 루틴은 메모리에서 Free frame을 찾고 Swap space에서 해당 페이지를 읽어 Free frame에 적재하고 valid bit를 1로 설정한다.
        5. 다시 1번을 수행한다.
24. Thrashing이란 무엇인지 설명하고 이를 해결하기 위한 기법을 하나 이상 설명해주세요.
    - Thrashing
        - 동시에 실행되는 프로세스 수가 어느정도 증가하면 CPU 이용률은 높아지나 필요 이상으로 증가하면 각 프로세스들이 사용할 수 있는 프레임의 수가 적어진다. 따라서, Page fault가 빈번하게 발생하고, Page In/Out이 잦아져 CPU 이용률이 떨어지므로 전체적인 성능이 저하된다.
    - Page fault frequency
          - 페이지 폴트율이 상한선(upper bound)보다 높아지면 해당 프로세스는 너무 적은 프레임을 갖고 있으므로 프레임의 수를 더 할당한다.
          - 페이지 폴트율이 하한선(lower bound)보다 낮아지면 해당 프로세스는 너무 많은 프레임을 갖고 있으므로 프레임을 회수한다.
          ![Page fault frequency](https://user-images.githubusercontent.com/14902866/276626273-0276becd-188a-4d9a-8cd7-848f993ae1ab.png)
25. 유닉스 파일 시스템에 대해 설명해주세요.
    - inode 기반 파일시스템
        - 파일의 크기, 권한, 생성 시간과 같은 메타데이터와 블록으로 이루어진 자료구조
            - 파일 생성 시 inode 고유 번호 부여하고 inode block 생성되어 메타데이터 저장
            - 사용자가 파일 이름으로 접근 시 [file-name]:[inode-number]로 인식
        - Blocks
            - Direct Block : 실제 데이터가 저장된 디스크의 특정 블록 주소를 직접 가리키는 포인터
            - Indirect Block : 다른 블록 주소를 가리키는 포인터들을 저장하는 블록, 다이렉트 블록만으로 데이터를 가리킬 수 없을 때 사용함
        - 사용 이유
            - inode 번호를 통해 실제 데이터 블록으로 빠르게 접근 가능
            - Hard/Symbolic Link 지원
                - Hard : 원본 < inode, 번호 동일, 원본 삭제 시 데이터 접근 가능
                    ```bash
                    $echo "hard link test" > origin
                    $ln origin hardlink

                    $ls -il
                    29589 -rw-r--r-- 2 eljoe eljoe   15 Oct 18 20:37 hardlink
                    29589 -rw-r--r-- 2 eljoe eljoe   15 Oct 18 20:37 origin

                    $rm origin
                    $cat hardlink
                    hard link test
                    ```
                - Symbolic : 원본 < 포인터 < inode, 번호 다름, 원본 삭제 시 데이터 접근 불가
                    ```bash
                    $echo "symbolic link test" > origin
                    $ln -s origin symlink

                    $ls -il
                    29615 -rw-r--r-- 1 eljoe eljoe   19 Oct 18 20:39 origin
                    29617 lrwxrwxrwx 1 eljoe eljoe    6 Oct 18 20:40 symlink -> origin

                    $rm origin
                    $cat symlink
                    cat: symlink: No such file or directory
                    ```
